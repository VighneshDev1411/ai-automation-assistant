// src/lib/supabase/storage.ts
import { createClient } from '@supabase/supabase-js'


const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!

// Create client without auth persistence
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    persistSession: false,
    autoRefreshToken: false,
  }
})

// Use only public bucket
export const STORAGE_BUCKETS = {
  DOCUMENTS: 'public-uploads',
  IMAGES: 'public-uploads',
  AVATARS: 'public-uploads',
  WORKFLOW_ASSETS: 'public-uploads',
  TEMP: 'public-uploads',
} as const

// Simplified upload function
// src/lib/supabase/storage.ts
export async function uploadFile(
  file: File,
  options: UploadOptions
): Promise<UploadResponse> {
  console.log('üì§ Starting upload:', {
    fileName: file.name,
    fileSize: file.size,
    fileType: file.type,
    bucket: STORAGE_BUCKETS[options.bucket]
  })

  try {
    // Use the public bucket
    const bucketName = 'public-uploads'
    console.log('ü™£ Using bucket:', bucketName)

    // Generate file path
    const fileExt = file.name.split('.').pop()
    const fileName = options.fileName || `${Date.now()}-${Math.random().toString(36).substring(7)}.${fileExt}`
    const filePath = options.folder ? `${options.folder}/${fileName}` : fileName
    
    console.log('üìÅ File path:', filePath)

    // Upload to Supabase Storage
    console.log('‚¨ÜÔ∏è Uploading to Supabase...')
    const { data, error } = await supabase.storage
      .from(bucketName)
      .upload(filePath, file, {
        cacheControl: '3600',
        upsert: true, // Changed to true to overwrite if exists
      })

    if (error) {
      console.error('‚ùå Supabase upload error:', error)
      throw error
    }

    console.log('‚úÖ Upload successful:', data)

    // Get public URL
    const { data: { publicUrl } } = supabase.storage
      .from(bucketName)
      .getPublicUrl(filePath)

    console.log('üîó Public URL:', publicUrl)

    return {
      success: true,
      data: {
        id: data.id || fileName,
        path: data.path,
        url: publicUrl,
        size: file.size,
        type: file.type,
        metadata: options.metadata,
      },
    }
  } catch (error) {
    console.error('‚ùå Upload error:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Upload failed',
    }
  }
}
// Other functions remain the same but use 'public-uploads' bucket
export async function deleteFile(bucket: any, path: string) {
  const { error } = await supabase.storage
    .from('public-uploads')
    .remove([path])
  
  return { success: !error, error: error?.message }
}

export async function listFiles(bucket: any, folder?: string) {
  const { data, error } = await supabase.storage
    .from('public-uploads')
    .list(folder)
  
  return {
    success: !error,
    data: data || [],
    error: error?.message
  }
}

export async function downloadFile(bucket: any, path: string) {
  const { data, error } = await supabase.storage
    .from('public-uploads')
    .download(path)
  
  return {
    success: !error,
    data,
    error: error?.message
  }
}




export const FILE_CONFIGS = {
  ALLOWED_IMAGE_TYPES: [
    'image/jpeg',
    'image/png',
    'image/gif',
    'image/webp',
    'image/svg+xml',
  ],
  ALLOWED_DOCUMENT_TYPES: [
    'application/pdf',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'application/vnd.ms-excel',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'text/plain',
    'text/csv',
    'application/json',
  ],
  MAX_FILE_SIZE: 50 * 1024 * 1024, // 50MB
  MAX_IMAGE_SIZE: 10 * 1024 * 1024, // 10MB
  IMAGE_QUALITY: 0.9,
  THUMBNAIL_SIZE: { width: 200, height: 200 },
  PREVIEW_SIZE: { width: 800, height: 800 },
}

// File upload options interface
interface UploadOptions {
  bucket: keyoxf typeof STORAGE_BUCKETS
  folder?: string
  fileName?: string
  metadata?: Record<string, any>
  onProgress?: (progress: number) => void
}

// File upload responses interface
interface UploadResponse {
  success: boolean
  data?: {
    id: string
    path: string
    url: string
    size: number
    type: string
    metadata?: Record<string, any>
  }
  error?: string
}





# WHAT IS UPSERT ? 



An upsert is a database operation that combines "update" and "insert" into a single command. It will update a record if it already exists, and insert a new record if it does not exist.


How It Works
The term "upsert" is a portmanteau of update and insert. The operation's logic follows a simple conditional flow:

Check for Existence: The database first checks if a record with a specific unique identifier (like a primary key or a unique index) already exists in the table.

Execute Action:

If the record exists: The database performs an UPDATE, modifying the existing record with the new data provided.

If the record does not exist: The database performs an INSERT, creating a new record with the provided data.

This process ensures that a record is present in the table with the latest information, without you having to manually check for its existence first.

Why Use Upsert?
Upserting is valuable for several reasons:

Simplicity & Efficiency: It combines two potential operations (checking for existence, then inserting or updating) into a single atomic command. This reduces the amount of code you need to write and minimizes round-trip communication between your application and the database.

Concurrency Safe: It helps prevent race conditions. Without upsert, two separate processes might simultaneously check for a record, both find it doesn't exist, and then both try to insert it, causing an error. An upsert operation handles this conflict gracefully.

Data Synchronization: It's perfect for tasks like synchronizing data from one system to another, where you just want the target system to match the source, regardless of whether the records are new or just updated.

Simple Example
Imagine you have a Users table with columns for UserID, Name, and Email. UserID is the unique key.

You want to add or update a user with UserID = 123.

Scenario 1: User 123 does not exist.
An UPSERT command for UserID = 123, Name = 'Alice', Email = 'alice@example.com' will insert a new row.

UserID	Name	Email
123	Alice	alice@example.com

Export to Sheets
Scenario 2: User 123 already exists.
The user exists with Name = 'Alice' and Email = 'old@example.com'. An UPSERT command for UserID = 123, Name = 'Alice', Email = 'new@example.com' will update the existing row.